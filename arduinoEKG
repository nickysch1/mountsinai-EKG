import pyfirmata2
import time
import datetime
import struct
import os
import json
from typing import Dict, Any
import h5py
import matplotlib.pyplot as plt
import numpy as np 
import csv
#simple test arduino EKG reader script with holo file parsing and timing sync
#by nicholas schnorbus 2025

print("ECG Data Collection Options:")
print("1. Collect new ECG data from Arduino")
print("2. Load existing untrimmed ECG JSON file")
choice = input("Enter your choice (1 or 2): ").strip()

ECG_data = []

if choice == "2":
    # Load existing ECG data
    ecg_file_path = input("Enter path to untrimmed ECG JSON file: ")
    ecg_file_path = ecg_file_path.strip().strip('"').strip("'")
    
    try:
        if os.path.exists(ecg_file_path):
            with open(ecg_file_path, 'r') as f:
                ECG_data = json.load(f)
            print(f"Loaded {len(ECG_data)} ECG data points from {ecg_file_path}")
            print(f"Data time range: {ECG_data[0]['timestamp_seconds']:.6f} to {ECG_data[-1]['timestamp_seconds']:.6f} seconds")
        else:
            print(f"File not found: {ecg_file_path}")
            print("Falling back to Arduino data collection...")
            choice = "1"
    except Exception as e:
        print(f"Error loading ECG file: {e}")
        print("Falling back to Arduino data collection...")
        choice = "1"

if choice == "1":
    print("\nStarting Arduino ECG data collection...")
    
    #get board info
    board = pyfirmata2.Arduino('COM4')

    it = pyfirmata2.util.Iterator(board)
    it.start()

    analogInput = board.get_pin('a:0:i')
    test = 0

    #target sampling rate
    target_hz = 200
    target_interval = 1.0 / target_hz 

    #start timing and setup for sample delay 
    start_time_ns = time.time_ns()  #absolute timestamp for synchronization
    start_time = start_time_ns / 1_000_000_000 
    perf_start_ns = time.perf_counter_ns()  #monotonic timer for intervals
    target_interval_ns = int(target_interval * 1_000_000_000) 
    next_sample_time_ns = perf_start_ns

    print("Sample#, Analog Value, Timestamp (ns)")
    while True:
        current_perf_ns = time.perf_counter_ns()
        elapsed_perf_ns = current_perf_ns - perf_start_ns
        elapsed_time = elapsed_perf_ns / 1_000_000_000  
        
        if elapsed_time >= 10:
            break
        
        #take sample when calculated time has passed
        if current_perf_ns >= next_sample_time_ns:
            test += 1
            analog_value = analogInput.value
            #get absolute timestamp
            timestamp_ns = time.time_ns()
            current_time = timestamp_ns / 1_000_000_000
            
            #store data
            ECG_data.append({
                'sample_num': test,
                'analog_value': analog_value,
                'timestamp_ns': timestamp_ns,
                'timestamp_seconds': current_time
            })
            
            print(f"{test}, {analog_value}, {timestamp_ns}")
            #add delay for next sample
            next_sample_time_ns += target_interval_ns
        
        
    #find actual sampling rate
    final_perf_ns = time.perf_counter_ns()
    actual_elapsed_ns = final_perf_ns - perf_start_ns
    actual_elapsed = actual_elapsed_ns / 1_000_000_000
    actual_hz = test / actual_elapsed

    #print results 
    print(f"Elapsed time: {actual_elapsed:.6f} seconds ({actual_elapsed_ns} nanoseconds)")
    print(f"Sampled {test} values")
    print(f"Target Hz: {target_hz}")
    print(f"Actual Hz: {actual_hz:.2f}")
    print(f"Average interval: {actual_elapsed_ns / test:.0f} ns per sample")
    print(f"Target interval: {target_interval_ns} ns per sample")

    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
    json_filename = f"Untrimmed_ECG_{timestamp}.json"
    with open(json_filename, 'w') as f:
        json.dump(ECG_data, f, indent=4)
    print(f"\n Untrimmed ECG data saved as JSON: {json_filename}")

else:
    print("Using loaded ECG data for analysis...")




#parse example holo file and extract timing info
path = input("Enter path to h5 file: ")
#clean up the path 
path = path.strip().strip('"').strip("'") 
print(f"Using path: {repr(path)}")
print("Attempting to parse h5 file...")

#make sure it exists
if os.path.exists(path):
    print("File found!")
    h5_data = h5py.File(path, 'r')
else:
    print(f"File not found: {path}")
    print("Please check the path and try again.")
    h5_data = {"error": "File not found"}

#extract time info and arterial velocity data
try:
    arterialVelocitySignal = h5_data['/SignalsArterialVelocity_y']
    #make scalar from h5 data
    unix_first_array = h5_data['/UnixTimestampFirst'][:]
    unix_last_array = h5_data['/UnixTimestampLast'][:]
    timing_info = {
        'unix_first': float(unix_first_array[0]) if len(unix_first_array) > 0 else float(unix_first_array),
        'unix_last': float(unix_last_array[0]) if len(unix_last_array) > 0 else float(unix_last_array)
    }
    print(f"HDF5 data loaded successfully")
    print(f"Arterial velocity signal shape: {arterialVelocitySignal.shape}")
    print(f"Timing range: {timing_info['unix_first']} to {timing_info['unix_last']} µs")
except Exception as e:
    print(f"Error reading HDF5 data: {e}")
    timing_info = {"error": "HDF5 data extraction failed"}
    arterialVelocitySignal = None

#pull out start and end times
if 'error' not in timing_info:
    holo_start_unix = float(timing_info['unix_first']) 
    holo_end_unix = float(timing_info['unix_last'])     
    duration_us = holo_end_unix - holo_start_unix       
    duration = duration_us / 1_000_000             
    
    print(f"Holo start Unix time: {holo_start_unix} µs ({holo_start_unix / 1_000_000:.6f} seconds)")
    print(f"Holo end Unix time: {holo_end_unix} µs ({holo_end_unix / 1_000_000:.6f} seconds)")
    print(f"Holo duration: {duration_us} µs ({duration:.6f} seconds)")
    
    #find closest ECG datapoint to holo timestamps 
    if ECG_data:
        holo_start_unix_ns = int(holo_start_unix * 1_000)  
        holo_end_unix_ns = int(holo_end_unix * 1_000)      
        
        closest_start_ECG = min(ECG_data, key=lambda x: abs(x['timestamp_ns'] - holo_start_unix_ns))
        closest_end_ECG = min(ECG_data, key=lambda x: abs(x['timestamp_ns'] - holo_end_unix_ns))
        
        start_time_diff_ns = abs(closest_start_ECG['timestamp_ns'] - holo_start_unix_ns)
        end_time_diff_ns = abs(closest_end_ECG['timestamp_ns'] - holo_end_unix_ns)
        start_time_diff = start_time_diff_ns / 1_000_000_000
        end_time_diff = end_time_diff_ns / 1_000_000_000
        
        print(f"\nClosest ECG datapoint to holo start (Unix: {holo_start_unix} µs):")
        print(f"ECG Sample #: {closest_start_ECG['sample_num']}")
        print(f"ECG Unix Timestamp: {closest_start_ECG['timestamp_seconds']:.6f} seconds")
        print(f"ECG Timestamp (ns): {closest_start_ECG['timestamp_ns']}")
        print(f"Time difference: {start_time_diff:.6f} seconds ({start_time_diff_ns} ns)")
        
        print(f"\nClosest ECG datapoint to holo end (Unix: {holo_end_unix} µs):")
        print(f"ECG Sample #: {closest_end_ECG['sample_num']}")
        print(f"ECG Unix Timestamp: {closest_end_ECG['timestamp_seconds']:.6f} seconds")
        print(f"ECG Timestamp (ns): {closest_end_ECG['timestamp_ns']}")
        print(f"Time difference: {end_time_diff:.6f} seconds ({end_time_diff_ns} ns)")
        
        #trim ECG data to match holo duration
        start_sample_num = closest_start_ECG['sample_num']
        end_sample_num = closest_end_ECG['sample_num']
        
        #extract trimmed data between start and end points inclusively 
        trimmed_ECG = [sample for sample in ECG_data if start_sample_num <= sample['sample_num'] <= end_sample_num]
        
        print(f"\nECG Data Trimming Results:")
        print(f"Original ECG samples: {len(ECG_data)}")
        print(f"Trimmed ECG samples: {len(trimmed_ECG)}")
        print(f"Trimmed range: Sample #{start_sample_num} to #{end_sample_num}")
        if trimmed_ECG:
            trimmed_duration = trimmed_ECG[-1]['timestamp_seconds'] - trimmed_ECG[0]['timestamp_seconds']
            print(f"Trimmed duration: {trimmed_duration:.6f} seconds")
        print(f"Holo duration: {duration:.6f} seconds")
        
        #create combined plot with ECG and arterial velocity data from HDF5
        #save ecg data
        if trimmed_ECG:
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            json_filename = f"trimmed_ECG_{timestamp}.json"
            with open(json_filename, 'w') as f:
                json.dump(trimmed_ECG, f, indent=4)
            print(f"\n ECG data saved as JSON: {json_filename}")
        
        if trimmed_ECG and arterialVelocitySignal is not None:
            #extract arterial velocity data 
            velocity_data = arterialVelocitySignal[:] 
            print(f"Loaded {len(velocity_data)} arterial velocity data points from HDF5")
            
            #extract ECG data for plotting 
            ecg_timestamps = [sample['timestamp_seconds'] for sample in trimmed_ECG]
            ecg_values = [sample['analog_value'] for sample in trimmed_ECG]
            
            #convert timestamps to relative time 
            start_timestamp = ecg_timestamps[0]
            ecg_time_relative = [(t - start_timestamp) for t in ecg_timestamps]
            
            #create the combined plot with HDF5 velocity data
            plt.figure(figsize=(14, 10))
            
            #create time axis for velocity data matching holo duration
            velocity_time = np.linspace(0, duration, len(velocity_data))
            
            #arterial velocity plot from HDF5
            plt.subplot(3, 1, 1)
            plt.plot(velocity_time, velocity_data, 'r-', linewidth=2, label='Arterial Velocity (HDF5)')
            plt.axvline(x=0, color='green', linestyle='--', linewidth=2, label='Holo Start')
            plt.axvline(x=duration, color='green', linestyle=':', linewidth=2, label='Holo End')
            plt.xlabel('Time (seconds)')
            plt.ylabel('Arterial Velocity')
            plt.title('Arterial Velocity')
            plt.legend()
            plt.grid(True, alpha=0.3)
            
            #ecg plot
            plt.subplot(3, 1, 2)
            plt.plot(ecg_time_relative, ecg_values, 'b-', linewidth=1, label='ECG Signal')
            plt.axvline(x=0, color='green', linestyle='--', linewidth=2, label='Sync Start')
            plt.axvline(x=max(ecg_time_relative), color='green', linestyle=':', linewidth=2, label='Sync End')
            plt.xlabel('Time (seconds)')
            plt.ylabel('ECG Amplitude')
            plt.title('ECG Signal')
            plt.legend()
            plt.grid(True, alpha=0.3)
            
            #combined plot 
            plt.subplot(3, 1, 3)
            
            # Create dual y-axes for the combined plot
            ax1 = plt.gca()  # Get current axes for arterial velocity
            ax2 = ax1.twinx()  # Create second y-axis for ECG
            
            # Plot arterial velocity on left y-axis (red)
            line1 = ax1.plot(velocity_time, velocity_data, 'r-', linewidth=2, label='Arterial Velocity (HDF5)', alpha=0.8)
            ax1.set_ylabel('Arterial Velocity', color='red')
            ax1.tick_params(axis='y', labelcolor='red')
            
            # Plot ECG on right y-axis (blue) 
            line2 = ax2.plot(ecg_time_relative, ecg_values, 'b-', linewidth=1, label='ECG Signal', alpha=0.8)
            ax2.set_ylabel('ECG Amplitude', color='blue')
            ax2.tick_params(axis='y', labelcolor='blue')
            
            # Set x-axis properties
            ax1.set_xlabel('Time (seconds)')
            ax1.grid(True, alpha=0.3)
            
            # Combine legends from both axes
            lines = line1 + line2
            labels = [l.get_label() for l in lines]
            ax1.legend(lines, labels, loc='upper left')
            
            plt.title('Arterial Velocity and ECG ')
            
            # Add vertical timing markers to both axes
            ax1.axvline(x=0, color='green', linestyle='--', linewidth=1, alpha=0.7)
            ax1.axvline(x=duration, color='green', linestyle=':', linewidth=1, alpha=0.7)
            
            plt.tight_layout()
            plt.show()
            
        
        
    else:
        print("No ECG data!")
        
else:
    print(f"Error extracting timing: {timing_info['error']}")

